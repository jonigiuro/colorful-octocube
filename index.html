<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Joni.G | Star</title>
<script src="Three.js"></script>
<script src="RequestAnimationFrame.js"></script>
<script type='text/javascript' src='DAT.GUI.min.js'></script>
<script src="jquery-1.6.js"></script>
<script language="javascript" type="text/javascript" src="Controls.js"></script>
</head>
<body style="overflow:hidden;background-image:url('back.jpg')">
	<div id="info" style="position:absolute; top:40px; font-family: Helvetica, Arial; padding:5px; color:#fff;background-color:#f55;font-size:0.6em;width:100px">
		<em>-- Chrome only --</em><br />
		Use scroll wheel to move camera on z<br /><br />
		Click to move camera in other directions <br /><br />
		Use the UI on the top right to change the trails length (the less -> the longer)<br /><br />
		Move your mouse to create the trail ( the center of the monitor makes a straight trail, otherwise it's going to tend to the left or to the right)
	</div>
	<div id="reset" style="position:absolute; top:10px; font-family: Helvetica, Arial; padding:5px; color:#fff;background-color:#f55;font-size:0.6em;width:100px">
		<strong>RESET</strong>
	</div>
<script>
var SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;
var NEAR = 5, FAR = 40000;
var create = true;
var depth = 700;
var col = 0;
var maxcubes = 1000;
var allCubes = new Array();
var colorthing = '0xffffff';
var shrink = 0.05;
var radius = 500;
var currentX = 0;
var currentY = 0;
var oldcount = 0;
var camera, scene, renderer, sphere,
material, ambient, light;
		var params = {
			maxcubes: 1000,
			shrink: 0.05
		};
    init();
    animate();

    function init() {
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.z = 400;
				camera.position.y = 0;
				camera.position.x = 0;
				camera.rotation.x=0;
				camera.rotation.y=0;
				camera.rotation.z=0;
        scene = new THREE.Scene();
				ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );
				light = new THREE.SpotLight( 0xffffff );
								light.position.set( 0, 350, 100 );
								light.target.position.set( 0, 0, 0 );
								light.castShadow = true;
								scene.add( light );
        renderer = new THREE.WebGLRenderer({ clearColor: 0x555555, clearAlpha: 0, antialias: true });
				//renderer = new THREE.CanvasRenderer({ clearColor: 0x000000, clearAlpha: 1, antialias: true });
				
        renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowCameraNear = 3;
								renderer.shadowCameraFar = camera.far;
								renderer.shadowCameraFov = 500;

								renderer.shadowMapBias = 0.0039;
								renderer.shadowMapDarkness = 0.5;
								renderer.shadowMapWidth = SHADOW_MAP_WIDTH;
								renderer.shadowMapHeight = SHADOW_MAP_HEIGHT;

								renderer.shadowMapEnabled = true;
								renderer.shadowMapSoft = true;
        document.body.appendChild( renderer.domElement );
				var material = new THREE.MeshBasicMaterial( { wireframe: true, opacity: 1 } );
				var geometry = new THREE.CubeGeometry( 7, 7, 7 );
				var mesh = new THREE.Mesh( geometry, material );
				mesh.castShadow = false;
				mesh.receiveShadow = false;
				mesh.position.y = 0;
				mesh.position.x = 0;
				mesh.position.z = -0;
				mesh.rotation.z = 3;
				//material.castshadow
				allCubes.push(mesh)
				scene.add( mesh );
				var boundmaterial = new THREE.MeshBasicMaterial( { wireframe: true, opacity: 1 } );
				var boundgeometry = new THREE.CubeGeometry( 600, 600, 600 );
				var boundmesh = new THREE.Mesh( boundgeometry, boundmaterial );
				boundmesh.castShadow = false;
				boundmesh.receiveShadow = false;
				boundmesh.position.y = 0;
				boundmesh.position.x = 0;
				boundmesh.position.z = -0;
				boundmesh.rotation.z = 0;
				//material.castshadow
				//allCubes.push(boundmesh)
				//scene.add( boundmesh );
    }

document.onmousewheel = wheel;

function wheel(event){
	radius += -1 * event.wheelDelta/2;
	camera.position.x = radius * Math.sin( currentX * Math.PI / 360 );
	camera.position.y = radius * Math.sin( currentY * Math.PI / window.innerHeight / 2 );
	camera.position.z = radius * Math.cos( currentX * Math.PI / 360 );
}

$("#reset").click(function(){	
		oldcount = allCubes.length;
		//scene.removeChild(allCubes[q])
		
	var material = new THREE.MeshBasicMaterial( { wireframe: true, opacity: 1 } );
	var geometry = new THREE.CubeGeometry( 7, 7, 7 );
	var mesh = new THREE.Mesh( geometry, material );
	mesh.castShadow = false;
	mesh.receiveShadow = false;
	mesh.position.y = 0;
	mesh.position.x = 0;
	mesh.position.z = -0;
	mesh.rotation.z = 3;
	//material.castshadow
	allCubes.push(mesh)
	return false;
})



$(document).mousemove(function(e){
	if(create == true){
		draw(e.clientX,e.clientY);
	}else{
		currentX = e.clientX;
		currentY = e.clientY;

		camera.position.x = radius * Math.sin( ( e.clientX ) * Math.PI / 360 );
		camera.position.y = radius * Math.sin( ( e.clientY ) * Math.PI / window.innerHeight / 2 );
		camera.position.z = radius * Math.cos( ( e.clientX ) * Math.PI / 360 );
	}
})

$(document).click(function(e){
	create =! create
})

function draw(clientX,clientY){
	col++;
	var addedMaterial = new THREE.MeshLambertMaterial( { wireframe: false, opacity: 1, color: colorthing } );
	var addedGeom = new THREE.CubeGeometry( 7, 7, 7 );
	var addedMesh = new THREE.Mesh( addedGeom, addedMaterial );
	addedMesh.castShadow = true;
	addedMesh.receiveShadow = true;
	addedMesh.position.y = allCubes[allCubes.length - 1].position.y + 7 *allCubes[allCubes.length - 1].scale.x * (Math.cos(allCubes[allCubes.length - 1].rotation.z));
	addedMesh.position.x = allCubes[allCubes.length - 1].position.x + 7 *allCubes[allCubes.length - 1].scale.x * (Math.sin(allCubes[allCubes.length - 1].rotation.z)) * -1;
	addedMesh.position.z = allCubes[allCubes.length - 1].position.z + 7 *allCubes[allCubes.length - 1].scale.x * (Math.cos(allCubes[allCubes.length - 1].rotation.y)) * -1;
	addedMesh.rotation.x = 0;
	addedMesh.rotation.y = allCubes[allCubes.length - 1].rotation.y + 0.1;
	addedMesh.rotation.z = allCubes[allCubes.length - 1].rotation.z + (clientX / window.innerWidth) - 0.5;
	addedMesh.scale.x = allCubes[allCubes.length - 1].scale.x - params.shrink;
	addedMesh.scale.y = allCubes[allCubes.length - 1].scale.x - 0.01;
	addedMesh.scale.z = allCubes[allCubes.length - 1].scale.x - 0.01;
	if(addedMesh.scale.x < 0){
		resetCube(addedMesh)
	}
	addedMesh.castShadow = true;
	addedMesh.recieveShadow = true;
	allCubes.push(addedMesh)
	scene.add( addedMesh );
}		

function resetCube(addedMesh){
	changecolor();
	addedMesh.position.y = 0
	addedMesh.position.x = 0
	addedMesh.position.z = 0
	addedMesh.scale.x=1;
	addedMesh.scale.y=1;
	addedMesh.scale.z=1;
}

function destroyCubes(){
	for(s=0;s<oldcount;s++){
		allCubes[s].scale.y = allCubes[s].scale.y * .9
		allCubes[s].scale.x = allCubes[s].scale.x * .9
		allCubes[s].scale.z = allCubes[s].scale.z * .9
		allCubes[s].position.y = allCubes[s].position.y * 1.02
		allCubes[s].position.x = allCubes[s].position.x * 1.02
		allCubes[s].position.z = allCubes[s].position.z * 1.02
	}

}
function changecolor(){
	colorthing = '0x'+ Math.floor((col%256-256)*(-1)).toString(16)+ Math.floor(col%128).toString(16)+ Math.floor(col%256).toString(16)
}

function animate() {

	if(allCubes.length > params.maxcubes){
		scene.removeChild(allCubes[allCubes.length - params.maxcubes])
	}
	if(create == true){
	//	camera.position.x=allCubes[allCubes.length - 1].position.x
	//	camera.position.y=allCubes[allCubes.length - 1].position.y
	//	camera.position.z=allCubes[allCubes.length - 1].position.z + 700
	}
	camera.lookAt(new THREE.Vector3(0,0,0))
	destroyCubes();
		
  requestAnimationFrame( animate );
  render();
}

function render() {
   renderer.render( scene, camera );
}

</script>
</body>
</html>